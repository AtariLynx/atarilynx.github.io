---
title: Development containers
abstract: Using container technology to create flexible development environment for Atari Lynx game development.
---

# Introduction to container technology
Installing the tooling for your preferred development environment to work on Atari Lynx code might turn out to be quite some work, repetitive, error-prone and hard to transfer or keep in sync with your code. Also, it usually requires certain prerequisites and tools to be present and installed on your development machine. When you work on more than one codebase and these assume different versions of the development suite, it might be even harder to maintain and run multiple versions simultaneously.

Over the past years container technology has become well established. Containers offer a runtime environment inside a host machine with isolation from its host for compute, storage and network. This makes container technology an efficient and safe way to run one or more instances of environments, that have their own programs, files and network access, without affecting your host computer. Containers share the operating system (OS) kernel with its host, but do not need to be exactly the same. Linux kernels are highly compatible, allowing you to run different Linux ditributions on any Linux machine. A Windows based host can leverage the Windows Subsystem for Linux (WSL) and virtualization to run both Windows and Linux containers.

## Container images
The "contain" part also refers to the fact that the environment contains all relevant prerequisites and installation. These are captured in container images that bundle all preparations for a working environment in a layered structure of files. Typically, a container image is built from a `Dockerfile` that describes the steps to execute to prepare the container environment in a flat-file text format. A container instance is started using an image of choice. Each container gets the exact same starting pointbased on the immutable image it was started from. Because of the isolation you can have multiple environments and versions running side by side, all having different files and used for different purposes, without interfering with each other.

Once container images are built locally or using automation pipelines, they can be stored and shared in a central location called container registries. Inside a registry you will find separate repositories for container images. One container repository is home to a single container image with all its variations and versions. When starting a new container instance you refer to the desired image location by its name and tag. This location can be a local image or one from a remote registry. 

## Running containers
Currently, there are several container stacks to choose from. The two predominant stacks are `Docker` and `Podman`. Both have installers for Windows, Linux and MacOS, so you should be able to find one to suit your needs. A stack typically consists of an container engine, to coordinate management and interaction of containers, plus additional tooling, such as an Application Programming Interface (API) for programmatic interaction and a command-line interface (CLI) for a terminal or batch-based support. 
A container can be started, paused and restarted whenever applicable. The container engine of the stack will manage all container instances, the available images, networking and other elements related to working with containers. The good part is that containers can be deleted after they were stopped. The deletion of the instance will remove all traces of the container that got created as part of the running and interaction with it. This means that all changes that seem to have been made to the original container image will disappear. Because the host system never had anything specific installed for the particular container, everything is completely clean and back to the state it was in before starting the container. Any changes that were made to the file system of the container were only happening inside the container. It would also destroy all your work that you performed in it. 

## Mounting files and folders
Containers can also mount files from the host, offering direct access to the  
host's file system, provided this way allowed and given by the host. Mounts appear as folders and files in the container. By storing your work in a mount location you essentially save your work outside of the container, thereby keeping it safe and avoiding loosing it whenever the container instance is deleted.

# Using containers as development environments
In the introduction to container technology we steered clear of details to work with container instances and images, as this is beyond scope at the moment. You can find a plentitude of books and online references on the topic of containers. It is recommended to read more on the topic if you want to learn about the underlying technology.
Hopefully you did get the idea that containers can be a great way to build and maintain runtime environments for development in general and retro games in particular. We can leverage the functionality and features to setup `cc65` and `newcc65` with `BLL` in container images and run our development environment as a container instance. You can adopt this way of working without much need to understand the details of containers. It will help if you do know more, but you can work with development containers regardless.

## Developing using containers
A development container is in essence a container. It has been enriched in such a way that it caters for typical needs when developing programs. This includes tools to work with the code, such as `Git` for version control, `make` to automate the build process and compilers like GNU C. In addition there is usually some form of connectivity support to work with these containers from an Integrated Development Environment (IDE). 
In 2021 Microsoft started standardizing work on development containers. These were called `Remote Containers` at the time, which was later renamed to `Devcontainers`. The specification of devcontainers have been open sourced and can be found at https://containers.dev. The specification aims for an un-orchestrated single container approach. It introduces concepts such as templates and features for reuse and offers configuration for both coding environments and continuous integration scenarios to build and test code.